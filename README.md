# Проекты

## Жесткий дедлайн: за сутки до экзамена

Каждый проект имеет минимальный набор задач (их хватит на 3 по курсу при условии, что большинство домашних заданий зачтено) и дополнительные задачи, позволяющие добрать баллов. Над проектом можно работать одному или вдвоем. В случае, если работаете вдвоем, обязательно брать дополнительные задачи.

Проект должен быть сопровожден отчетом, в котором описаны:

* Постановка задачи
* В случае командной работы, кто какие задачи делал
* Как задачи решали, архитектура решения
* Мотивация выбора тех или иных библиотек/принятия тех или иных архитектурных решений
* Исследование производительности/сравнение подходов

Записаться на проект можно в [табличке](https://docs.google.com/spreadsheets/d/16xKzLjcV0_CsiSv4LETbE_8BTIOohFGgaiXjKJxwXaI/edit?usp=sharing)

### Интерпретатор (нетипизируемый язык L)

[Описание языка](https://drive.google.com/file/d/1evYQJFJAechTD-nL59YQmp1VWmokjsbU/view?usp=sharing)

Минимум:

* Консольный (или другой пользовательский) интерфейс
* Парсер программ на языке из входного файла (можно пользоваться библиотеками)
* Интерпретатор программ на языке с печатью результата в выходной файл
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Добавить в язык функции
* Добавить типизацию (GADTs)
* Сравнение small-step и big-step семантики (качественно и количественно)
* Property-based тестирование

### Интерпретатор (PCF)

[Описание языка](http://www.cse.chalmers.se/edu/year/2018/course/DAT350/PCF.pdf)

Минимум:

* Консольный (или другой пользовательский) интерфейс
* Парсер программ на языке из входного файла (можно пользоваться библиотеками)
* Тайпчекер (можно вручную, можно GADTs)
* Интерпретатор программ на языке с печатью результата в выходной файл
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Добавить в язык рекурсивные типы
* Сравнение small-step и big-step семантики (качественно и количественно)
* Property-based тестирование

### Лямбда-исчисление

Минимум:

* Консольный (или другой пользовательский) интерфейс
* Парсер программ на языке из входного файла (можно пользоваться библиотеками)
* Преобразование из обычной записи в de Bruijn и locally-nameless
* Реализация одной из стратегий редукций
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Добавить типизацию (любую на выбор)
* Сравнение нескольких стратегий редукций (качественно и количественно)
* Property-based тестирование

### Стат-анализ для L

Эта задача естественным образом включает в себя интерпретатор для языка L с функциями, поэтому ее лучше делать в команде.

Минимум:

* Минимум задачи "Интерпретатор (нетипизированный язык L)" + функции
* Реализация value-range анализа
* Использование value-range анализа для оптимизирующей source-to-source трансформации кода

Дополнительные задачи:

* Дополнительные трансформации кода
* Сравнение производительности до и после трансформации
* Property-based тестирование

### Реализация системы типов Hindley–Milner

Минимум:

* Консольный (или другой пользовательский) интерфейс
* Парсер программ на языке из входного файла (можно пользоваться библиотеками)
* Вывод типов
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Добавить в язык рекурсивные определения
* Добавить в язык overloading
* Property-based тестирование

### Демонстрация стратегий редукции лямбда-термов

В этой задаче упор на то, чтобы (красиво) пошагово демонстрировать стратегии вычисления для лямбда-термов.

Минимум:

* Веб (или другой пользовательский) интерфейс
* Парсер программ на языке из входного файла (можно пользоваться библиотеками)
* Пошаговое выполнение редукций и их демонстрация
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Выбор: показать следующий шаг редукции, промотать k следующих, показать только результат (не должно зацикливаться)
* Сбор статистики и сравнение разных стратегий редукции
* Property-based тестирование

### Симуляция работы конечного автомата

В этой задаче упор на то, чтобы (красиво) пошагово демонстрировать, как работает конечный автомат.

Минимум:

* Веб (или другой пользовательский) интерфейс
* Парсер описания детерминированного конечного автомата и входной строки из входного файла (можно пользоваться библиотеками)
* Пошаговая симуляция работы (лучше на графе конечного автомата)
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Выбор: показать следующий шаг работы, промотать следующие k шагов, показать только результат
* Поддержка работы с недетерминированными автоматами, отображение неуспешных разборов.
* Property-based тестирование

### Решатель для Wordle

Тут важно постараться сделать его максимально эффективным

Минимум:

* Консольный (или другой пользовательский) интерфейс
* Пользователь выбирает слово, вы ему возвращаете отгадки: на каких позициях правильно отгаданы буквы, какие буквы есть в загаданном слове
* Поиск слов, подходящих под текущий набор отгадок
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Вычислить "оптимальное" первое слово, то есть то, которое позволит угадать любое из слов словаря за наименьшее количество шагов. Словарь тут -- параметр (слова, которые были в предыдущие дни, не могут быть загаданными).
* Сравнение производительности тупой реализации на строках и оптимизированной
* Property-based тестирование

### Rock-paper-scissors

Эта задача вычислительно простая, поэтому рекомендую ее брать тем, кто хочет потратить время на пользовательский интерфейс.

Минимум:

* Телеграм-бот или любой другой пользовательский интерфейс
* Интерактивный режим с пользователем и компьютером или несколько потоков, играющих друг с другом
* Каждый играющий выбирает камень, ножницы, или бумагу закрыто от других игроков. Когда все готовы, программа говорит, кто выиграл.
* В случае нескольких игроков, выбрать стратегию, например игру на выбывание
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Возможность задать свои правила (see rock-paper-scissors-lizard-spock) с проверкой их сбалансированности
* Игрок-компьютер может изучать историю игры с конкретным игроком-человеком и учитывать это, делая свой выбор
* Property-based тестирование

### Крестики-нолики

Минимум:

* Веб (или другой пользовательский) интерфейс
* Поле 3*3, 2 игрока
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Выбор размера поля и количества игроков
* Бесконечное поле
* Игра против компьютера
* Property-based тестирование

### Minesweeper

Минимум:

* Веб (или другой пользовательский) интерфейс
* Поле фиксированного размера, фиксированное количество мин, случайная генерация поля
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Выбор размера поля и количества мин
* Property-based тестирование

### Pixel art generator

Пример картинок можно смотреть [тут](https://giventofly.github.io/pixelit/#examples)

Минимум:

* Консольный (или другой пользовательский) интерфейс
* Загрузка картинки в формате png (можно пользоваться готовым загрузчиком)
* Пикселизация изображения
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Возможность выбрать размер пикселя и цветовую гамму
* Property-based тестирование

### Вычислительная математика

Почитать про алгоритмы вычисления определенных интегралов можно [тут](https://habr.com/ru/post/420867/)

Минимум:

* Библиотека
* Пользователь задает допустимую ошибку и определенный интеграл как функцию на хаскелле
* Реализуете 3 метода вычисления определенного интеграла
* Обработка ошибок
* Юнит-тесты

Дополнительные задачи:

* Консольный (или другой пользовательский) интерфейс, где пользователь может задать определенный интеграл и получить ответ, не кодя на хаскелле
* Вычисление ошибок и того, сколько шагов потребовалось, чтобы достичь результата
* Сравнение трех методов между собой
* Property-based тестирование
